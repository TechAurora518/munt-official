// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from libunity.djinni

#ifndef DJINNI_GENERATED_NJSGULDENUNIFIEDFRONTEND_HPP
#define DJINNI_GENERATED_NJSGULDENUNIFIEDFRONTEND_HPP


#include "balance_record.hpp"
#include "input_record.hpp"
#include "mutation_record.hpp"
#include "output_record.hpp"
#include "transaction_record.hpp"
#include <string>

#include <nan.h>
#include <node.h>
#include <gulden_unified_frontend.hpp>

using namespace v8;
using namespace node;
using namespace std;

class NJSGuldenUnifiedFrontend: public ::GuldenUnifiedFrontend {
public:

    static void Initialize(Local<Object> target);

    static Local<Object> wrap(const std::shared_ptr<::GuldenUnifiedFrontend> &object);
    static Nan::Persistent<ObjectTemplate> GuldenUnifiedFrontend_prototype;
    ~NJSGuldenUnifiedFrontend()
    {
        njs_impl.Reset();
    };
    NJSGuldenUnifiedFrontend(Local<Object> njs_implementation){njs_impl.Reset(njs_implementation);};

    /**
     * Fraction of work done since session start or last progress reset [0..1]
     * Unified progress combines connection state, header and block sync
     */
    void notifyUnifiedProgress(float progress);

    void notifyBalanceChange(const BalanceRecord & new_balance);

    /**
     * Notification of new mutations.
     * If self_committed it is due to a call to performPaymentToRecipient, else it is because of a transaction
     * reached us in another way. In general this will be because we received funds from someone, hower there are
     * also cases where funds is send from our wallet while !self_committed (for example by a linked desktop wallet
     * or another wallet instance using the same keys as ours).
     */
    void notifyNewMutation(const MutationRecord & mutation, bool self_committed);

    void notifyUpdatedTransaction(const TransactionRecord & transaction);

    void notifyInitWithExistingWallet();

    void notifyInitWithoutExistingWallet();

    void notifyShutdown();

    void notifyCoreReady();

    void logPrint(const std::string & str);

private:
    /**
     * Fraction of work done since session start or last progress reset [0..1]
     * Unified progress combines connection state, header and block sync
     */
    static NAN_METHOD(notifyUnifiedProgress);
    void notifyUnifiedProgress_aimpl__(float progress);

    static NAN_METHOD(notifyBalanceChange);
    void notifyBalanceChange_aimpl__(const BalanceRecord & new_balance);

    /**
     * Notification of new mutations.
     * If self_committed it is due to a call to performPaymentToRecipient, else it is because of a transaction
     * reached us in another way. In general this will be because we received funds from someone, hower there are
     * also cases where funds is send from our wallet while !self_committed (for example by a linked desktop wallet
     * or another wallet instance using the same keys as ours).
     */
    static NAN_METHOD(notifyNewMutation);
    void notifyNewMutation_aimpl__(const MutationRecord & mutation, bool self_committed);

    static NAN_METHOD(notifyUpdatedTransaction);
    void notifyUpdatedTransaction_aimpl__(const TransactionRecord & transaction);

    static NAN_METHOD(notifyInitWithExistingWallet);
    void notifyInitWithExistingWallet_aimpl__();

    static NAN_METHOD(notifyInitWithoutExistingWallet);
    void notifyInitWithoutExistingWallet_aimpl__();

    static NAN_METHOD(notifyShutdown);
    void notifyShutdown_aimpl__();

    static NAN_METHOD(notifyCoreReady);
    void notifyCoreReady_aimpl__();

    static NAN_METHOD(logPrint);
    void logPrint_aimpl__(const std::string & str);

    static NAN_METHOD(New);

    Nan::Persistent<Object> njs_impl;
};
#endif //DJINNI_GENERATED_NJSGULDENUNIFIEDFRONTEND_HPP
