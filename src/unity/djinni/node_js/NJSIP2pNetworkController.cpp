// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from libunity.djinni

#include "NJSIP2pNetworkController.hpp"
using namespace std;

void NJSIP2pNetworkController::setListener(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        Napi::Error::New(env, "NJSIP2pNetworkController::setListener needs 1 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::shared_ptr<NJSIP2pNetworkListener> arg_0(std::shared_ptr<NJSIP2pNetworkListener>{}, NJSIP2pNetworkListener::Unwrap(info[0].As<Napi::Object>()));

    try
    {
        IP2pNetworkController::setListener(arg_0);
    }
    catch (std::exception& e)
    {
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        return;
    }
    catch (...)
    {
        Napi::Error::New(env, "core exception thrown").ThrowAsJavaScriptException();
        return;
    }
}
void NJSIP2pNetworkController::disableNetwork(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSIP2pNetworkController::disableNetwork needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    try
    {
        IP2pNetworkController::disableNetwork();
    }
    catch (std::exception& e)
    {
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        return;
    }
    catch (...)
    {
        Napi::Error::New(env, "core exception thrown").ThrowAsJavaScriptException();
        return;
    }
}
void NJSIP2pNetworkController::enableNetwork(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSIP2pNetworkController::enableNetwork needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    try
    {
        IP2pNetworkController::enableNetwork();
    }
    catch (std::exception& e)
    {
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        return;
    }
    catch (...)
    {
        Napi::Error::New(env, "core exception thrown").ThrowAsJavaScriptException();
        return;
    }
}
Napi::Value NJSIP2pNetworkController::getPeerInfo(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSIP2pNetworkController::getPeerInfo needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    try
    {
        auto result = IP2pNetworkController::getPeerInfo();

        //Wrap result in node object
        auto arg_0 = Napi::Array::New(env);
        for(size_t arg_0_id = 0; arg_0_id < result.size(); arg_0_id++)
        {
            auto arg_0_elem = Napi::Object::New(env);
            auto arg_0_elem_1 = Napi::Value::From(env, result[arg_0_id].id);
            arg_0_elem.Set("id", arg_0_elem_1);
            auto arg_0_elem_2 = Napi::String::New(env, result[arg_0_id].ip);
            arg_0_elem.Set("ip", arg_0_elem_2);
            auto arg_0_elem_3 = Napi::String::New(env, result[arg_0_id].hostname);
            arg_0_elem.Set("hostname", arg_0_elem_3);
            auto arg_0_elem_4 = Napi::Value::From(env, result[arg_0_id].start_height);
            arg_0_elem.Set("start_height", arg_0_elem_4);
            auto arg_0_elem_5 = Napi::Value::From(env, result[arg_0_id].synced_height);
            arg_0_elem.Set("synced_height", arg_0_elem_5);
            auto arg_0_elem_6 = Napi::Value::From(env, result[arg_0_id].common_height);
            arg_0_elem.Set("common_height", arg_0_elem_6);
            auto arg_0_elem_7 = Napi::Value::From(env, result[arg_0_id].latency);
            arg_0_elem.Set("latency", arg_0_elem_7);
            auto arg_0_elem_8 = Napi::String::New(env, result[arg_0_id].userAgent);
            arg_0_elem.Set("userAgent", arg_0_elem_8);
            auto arg_0_elem_9 = Napi::Value::From(env, result[arg_0_id].protocol);
            arg_0_elem.Set("protocol", arg_0_elem_9);

            arg_0.Set((int)arg_0_id,arg_0_elem);
        }


        return arg_0;
    }
    catch (std::exception& e)
    {
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        return Napi::Value();
    }
    catch (...)
    {
        Napi::Error::New(env, "core exception thrown").ThrowAsJavaScriptException();
        return Napi::Value();
    }
}

Napi::FunctionReference NJSIP2pNetworkController::constructor;

Napi::Object NJSIP2pNetworkController::Init(Napi::Env env, Napi::Object exports) {

    // Hook all method callbacks
    Napi::Function func = DefineClass(env, "NJSIP2pNetworkController", {
    InstanceMethod("setListener", &NJSIP2pNetworkController::setListener),
    InstanceMethod("disableNetwork", &NJSIP2pNetworkController::disableNetwork),
    InstanceMethod("enableNetwork", &NJSIP2pNetworkController::enableNetwork),
    InstanceMethod("getPeerInfo", &NJSIP2pNetworkController::getPeerInfo),
    });
    // Create a peristent reference to the class constructor. This will allow a function called on a class prototype and a function called on instance of a class to be distinguished from each other.
    constructor = Napi::Persistent(func);
    // Call the SuppressDestruct() method on the static data prevent the calling to this destructor to reset the reference when the environment is no longer available.
    constructor.SuppressDestruct();
    exports.Set("NJSIP2pNetworkController", func);
    return exports;
}
