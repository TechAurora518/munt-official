// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from libunity.djinni

#include "NJSUnifiedBackendCpp.hpp"
using namespace std;

Napi::Value NJSUnifiedBackend::BuildInfo(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::BuildInfo needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::BuildInfo();

    //Wrap result in node object
    auto arg_0 = Napi::String::New(env, result);

    return arg_0;
}
Napi::Value NJSUnifiedBackend::InitUnityLib(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 8)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::InitUnityLib needs 8 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();
    std::string arg_1 = info[1].As<Napi::String>();
    auto arg_2 = info[2].ToNumber().Int64Value();
    auto arg_3 = info[3].ToNumber().Int64Value();
    auto arg_4 = info[4].ToBoolean().Value();
    auto arg_5 = info[5].ToBoolean().Value();
    std::shared_ptr<UnifiedFrontend> arg_6(Napi::ObjectWrap<UnifiedFrontend>::Unwrap(info[6].As<Napi::Object>()));

    std::string arg_7 = info[7].As<Napi::String>();

    auto result = UnifiedBackend::InitUnityLib(arg_0,arg_1,arg_2,arg_3,arg_4,arg_5,arg_6,arg_7);

    //Wrap result in node object
    auto arg_8 = Napi::Number::New(env, result);

    return arg_8;
}
void NJSUnifiedBackend::InitUnityLibThreaded(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 8)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::InitUnityLibThreaded needs 8 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();
    std::string arg_1 = info[1].As<Napi::String>();
    auto arg_2 = info[2].ToNumber().Int64Value();
    auto arg_3 = info[3].ToNumber().Int64Value();
    auto arg_4 = info[4].ToBoolean().Value();
    auto arg_5 = info[5].ToBoolean().Value();
    std::shared_ptr<UnifiedFrontend> arg_6(Napi::ObjectWrap<UnifiedFrontend>::Unwrap(info[6].As<Napi::Object>()));

    std::string arg_7 = info[7].As<Napi::String>();
    UnifiedBackend::InitUnityLibThreaded(arg_0,arg_1,arg_2,arg_3,arg_4,arg_5,arg_6,arg_7);
}
Napi::Value NJSUnifiedBackend::InitWalletFromRecoveryPhrase(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::InitWalletFromRecoveryPhrase needs 2 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();
    std::string arg_1 = info[1].As<Napi::String>();

    auto result = UnifiedBackend::InitWalletFromRecoveryPhrase(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Napi::Boolean::New(env, result);

    return arg_2;
}
Napi::Value NJSUnifiedBackend::ContinueWalletFromRecoveryPhrase(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::ContinueWalletFromRecoveryPhrase needs 2 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();
    std::string arg_1 = info[1].As<Napi::String>();

    auto result = UnifiedBackend::ContinueWalletFromRecoveryPhrase(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Napi::Boolean::New(env, result);

    return arg_2;
}
Napi::Value NJSUnifiedBackend::InitWalletLinkedFromURI(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::InitWalletLinkedFromURI needs 2 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();
    std::string arg_1 = info[1].As<Napi::String>();

    auto result = UnifiedBackend::InitWalletLinkedFromURI(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Napi::Boolean::New(env, result);

    return arg_2;
}
Napi::Value NJSUnifiedBackend::ContinueWalletLinkedFromURI(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::ContinueWalletLinkedFromURI needs 2 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();
    std::string arg_1 = info[1].As<Napi::String>();

    auto result = UnifiedBackend::ContinueWalletLinkedFromURI(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Napi::Boolean::New(env, result);

    return arg_2;
}
Napi::Value NJSUnifiedBackend::InitWalletFromAndroidLegacyProtoWallet(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 3)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::InitWalletFromAndroidLegacyProtoWallet needs 3 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();
    std::string arg_1 = info[1].As<Napi::String>();
    std::string arg_2 = info[2].As<Napi::String>();

    auto result = UnifiedBackend::InitWalletFromAndroidLegacyProtoWallet(arg_0,arg_1,arg_2);

    //Wrap result in node object
    auto arg_3 = Napi::Boolean::New(env, result);

    return arg_3;
}
Napi::Value NJSUnifiedBackend::isValidAndroidLegacyProtoWallet(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::isValidAndroidLegacyProtoWallet needs 2 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();
    std::string arg_1 = info[1].As<Napi::String>();

    auto result = UnifiedBackend::isValidAndroidLegacyProtoWallet(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Napi::Number::New(env, (int)result);

    return arg_2;
}
Napi::Value NJSUnifiedBackend::IsValidLinkURI(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::IsValidLinkURI needs 1 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();

    auto result = UnifiedBackend::IsValidLinkURI(arg_0);

    //Wrap result in node object
    auto arg_1 = Napi::Boolean::New(env, result);

    return arg_1;
}
Napi::Value NJSUnifiedBackend::ReplaceWalletLinkedFromURI(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::ReplaceWalletLinkedFromURI needs 2 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();
    std::string arg_1 = info[1].As<Napi::String>();

    auto result = UnifiedBackend::ReplaceWalletLinkedFromURI(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Napi::Boolean::New(env, result);

    return arg_2;
}
Napi::Value NJSUnifiedBackend::EraseWalletSeedsAndAccounts(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::EraseWalletSeedsAndAccounts needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::EraseWalletSeedsAndAccounts();

    //Wrap result in node object
    auto arg_0 = Napi::Boolean::New(env, result);

    return arg_0;
}
Napi::Value NJSUnifiedBackend::IsValidRecoveryPhrase(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::IsValidRecoveryPhrase needs 1 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();

    auto result = UnifiedBackend::IsValidRecoveryPhrase(arg_0);

    //Wrap result in node object
    auto arg_1 = Napi::Boolean::New(env, result);

    return arg_1;
}
Napi::Value NJSUnifiedBackend::GenerateRecoveryMnemonic(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::GenerateRecoveryMnemonic needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::GenerateRecoveryMnemonic();

    //Wrap result in node object
    auto arg_0 = Napi::String::New(env, result);

    return arg_0;
}
Napi::Value NJSUnifiedBackend::GenerateGenesisKeys(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::GenerateGenesisKeys needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::GenerateGenesisKeys();

    //Wrap result in node object
    auto arg_0 = Napi::String::New(env, result);

    return arg_0;
}
Napi::Value NJSUnifiedBackend::ComposeRecoveryPhrase(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::ComposeRecoveryPhrase needs 2 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();
    auto arg_1 = info[1].ToNumber().Int64Value();

    auto result = UnifiedBackend::ComposeRecoveryPhrase(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Napi::String::New(env, result);

    return arg_2;
}
void NJSUnifiedBackend::TerminateUnityLib(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::TerminateUnityLib needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    UnifiedBackend::TerminateUnityLib();
}
Napi::Value NJSUnifiedBackend::QRImageFromString(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::QRImageFromString needs 2 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();
    auto arg_1 = info[1].ToNumber().Int32Value();

    auto result = UnifiedBackend::QRImageFromString(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Napi::Object::New(env);
    auto arg_2_1 = Napi::Number::New(env, result.width);
    arg_2.Set("width", arg_2_1);
    auto arg_2_2 = Napi::Array::New(env);
    for(size_t arg_2_2_id = 0; arg_2_2_id < result.pixel_data.size(); arg_2_2_id++)
    {
        auto arg_2_2_elem = Napi::Number::New(env, result.pixel_data[arg_2_2_id]);
        arg_2_2.Set((int)arg_2_2_id,arg_2_2_elem);
    }

    arg_2.Set("pixel_data", arg_2_2);


    return arg_2;
}
Napi::Value NJSUnifiedBackend::GetReceiveAddress(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::GetReceiveAddress needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::GetReceiveAddress();

    //Wrap result in node object
    auto arg_0 = Napi::String::New(env, result);

    return arg_0;
}
Napi::Value NJSUnifiedBackend::GetRecoveryPhrase(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::GetRecoveryPhrase needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::GetRecoveryPhrase();

    //Wrap result in node object
    auto arg_0 = Napi::String::New(env, result);

    return arg_0;
}
Napi::Value NJSUnifiedBackend::IsMnemonicWallet(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::IsMnemonicWallet needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::IsMnemonicWallet();

    //Wrap result in node object
    auto arg_0 = Napi::Boolean::New(env, result);

    return arg_0;
}
Napi::Value NJSUnifiedBackend::IsMnemonicCorrect(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::IsMnemonicCorrect needs 1 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();

    auto result = UnifiedBackend::IsMnemonicCorrect(arg_0);

    //Wrap result in node object
    auto arg_1 = Napi::Boolean::New(env, result);

    return arg_1;
}
Napi::Value NJSUnifiedBackend::GetMnemonicDictionary(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::GetMnemonicDictionary needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::GetMnemonicDictionary();

    //Wrap result in node object
    auto arg_0 = Napi::Array::New(env);
    for(size_t arg_0_id = 0; arg_0_id < result.size(); arg_0_id++)
    {
        auto arg_0_elem = Napi::String::New(env, result[arg_0_id]);
        arg_0.Set((int)arg_0_id,arg_0_elem);
    }


    return arg_0;
}
Napi::Value NJSUnifiedBackend::UnlockWallet(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::UnlockWallet needs 1 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();

    auto result = UnifiedBackend::UnlockWallet(arg_0);

    //Wrap result in node object
    auto arg_1 = Napi::Boolean::New(env, result);

    return arg_1;
}
Napi::Value NJSUnifiedBackend::LockWallet(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::LockWallet needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::LockWallet();

    //Wrap result in node object
    auto arg_0 = Napi::Boolean::New(env, result);

    return arg_0;
}
Napi::Value NJSUnifiedBackend::ChangePassword(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::ChangePassword needs 2 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();
    std::string arg_1 = info[1].As<Napi::String>();

    auto result = UnifiedBackend::ChangePassword(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Napi::Boolean::New(env, result);

    return arg_2;
}
Napi::Value NJSUnifiedBackend::HaveUnconfirmedFunds(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::HaveUnconfirmedFunds needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::HaveUnconfirmedFunds();

    //Wrap result in node object
    auto arg_0 = Napi::Boolean::New(env, result);

    return arg_0;
}
Napi::Value NJSUnifiedBackend::GetBalance(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::GetBalance needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::GetBalance();

    //Wrap result in node object
    auto arg_0 = Napi::Number::New(env, result);

    return arg_0;
}
void NJSUnifiedBackend::DoRescan(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::DoRescan needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    UnifiedBackend::DoRescan();
}
Napi::Value NJSUnifiedBackend::IsValidRecipient(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::IsValidRecipient needs 1 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto field_arg_0_1 = info[0].ToObject().Get("scheme");
    if (field_arg_0_1.IsEmpty() || field_arg_0_1.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'scheme' field").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    std::string arg_0_1 = field_arg_0_1.As<Napi::String>();

    auto field_arg_0_2 = info[0].ToObject().Get("path");
    if (field_arg_0_2.IsEmpty() || field_arg_0_2.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'path' field").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    std::string arg_0_2 = field_arg_0_2.As<Napi::String>();

    auto field_arg_0_3 = info[0].ToObject().Get("items");
    if (field_arg_0_3.IsEmpty() || field_arg_0_3.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'items' field").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    unordered_map<std::string, std::string> arg_0_3;
    auto arg_0_3_prop_names = field_arg_0_3.ToObject().GetPropertyNames();
    for(uint32_t arg_0_3_id = 0; arg_0_3_id < arg_0_3_prop_names.Length(); arg_0_3_id++)
    {
        std::string arg_0_3_key = arg_0_3_prop_names.Get(arg_0_3_id).ToString();
        std::string arg_0_3_value = arg_0_3_prop_names.Get(arg_0_3_key).ToString();
        arg_0_3.emplace(arg_0_3_key,arg_0_3_value);
    }

    UriRecord arg_0(arg_0_1, arg_0_2, arg_0_3);


    auto result = UnifiedBackend::IsValidRecipient(arg_0);

    //Wrap result in node object
    auto arg_1 = Napi::Object::New(env);
    auto arg_1_1 = Napi::Boolean::New(env, result.valid);
    arg_1.Set("valid", arg_1_1);
    auto arg_1_2 = Napi::String::New(env, result.address);
    arg_1.Set("address", arg_1_2);
    auto arg_1_3 = Napi::String::New(env, result.label);
    arg_1.Set("label", arg_1_3);
    auto arg_1_4 = Napi::String::New(env, result.desc);
    arg_1.Set("desc", arg_1_4);
    auto arg_1_5 = Napi::Number::New(env, result.amount);
    arg_1.Set("amount", arg_1_5);


    return arg_1;
}
Napi::Value NJSUnifiedBackend::feeForRecipient(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::feeForRecipient needs 1 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto field_arg_0_1 = info[0].ToObject().Get("valid");
    if (field_arg_0_1.IsEmpty() || field_arg_0_1.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'valid' field").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    auto arg_0_1 = field_arg_0_1.ToBoolean().Value();

    auto field_arg_0_2 = info[0].ToObject().Get("address");
    if (field_arg_0_2.IsEmpty() || field_arg_0_2.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'address' field").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    std::string arg_0_2 = field_arg_0_2.As<Napi::String>();

    auto field_arg_0_3 = info[0].ToObject().Get("label");
    if (field_arg_0_3.IsEmpty() || field_arg_0_3.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'label' field").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    std::string arg_0_3 = field_arg_0_3.As<Napi::String>();

    auto field_arg_0_4 = info[0].ToObject().Get("desc");
    if (field_arg_0_4.IsEmpty() || field_arg_0_4.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'desc' field").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    std::string arg_0_4 = field_arg_0_4.As<Napi::String>();

    auto field_arg_0_5 = info[0].ToObject().Get("amount");
    if (field_arg_0_5.IsEmpty() || field_arg_0_5.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'amount' field").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    auto arg_0_5 = field_arg_0_5.ToNumber().Int64Value();
    UriRecipient arg_0(arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5);


    auto result = UnifiedBackend::feeForRecipient(arg_0);

    //Wrap result in node object
    auto arg_1 = Napi::Number::New(env, result);

    return arg_1;
}
Napi::Value NJSUnifiedBackend::performPaymentToRecipient(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::performPaymentToRecipient needs 2 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto field_arg_0_1 = info[0].ToObject().Get("valid");
    if (field_arg_0_1.IsEmpty() || field_arg_0_1.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'valid' field").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    auto arg_0_1 = field_arg_0_1.ToBoolean().Value();

    auto field_arg_0_2 = info[0].ToObject().Get("address");
    if (field_arg_0_2.IsEmpty() || field_arg_0_2.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'address' field").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    std::string arg_0_2 = field_arg_0_2.As<Napi::String>();

    auto field_arg_0_3 = info[0].ToObject().Get("label");
    if (field_arg_0_3.IsEmpty() || field_arg_0_3.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'label' field").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    std::string arg_0_3 = field_arg_0_3.As<Napi::String>();

    auto field_arg_0_4 = info[0].ToObject().Get("desc");
    if (field_arg_0_4.IsEmpty() || field_arg_0_4.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'desc' field").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    std::string arg_0_4 = field_arg_0_4.As<Napi::String>();

    auto field_arg_0_5 = info[0].ToObject().Get("amount");
    if (field_arg_0_5.IsEmpty() || field_arg_0_5.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'amount' field").ThrowAsJavaScriptException();
        return Napi::Value();
    }
    auto arg_0_5 = field_arg_0_5.ToNumber().Int64Value();
    UriRecipient arg_0(arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5);

    auto arg_1 = info[1].ToBoolean().Value();

    auto result = UnifiedBackend::performPaymentToRecipient(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Napi::Number::New(env, (int)result);

    return arg_2;
}
Napi::Value NJSUnifiedBackend::getTransactionHistory(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::getTransactionHistory needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::getTransactionHistory();

    //Wrap result in node object
    auto arg_0 = Napi::Array::New(env);
    for(size_t arg_0_id = 0; arg_0_id < result.size(); arg_0_id++)
    {
        auto arg_0_elem = Napi::Object::New(env);
        auto arg_0_elem_1 = Napi::String::New(env, result[arg_0_id].txHash);
        arg_0_elem.Set("txHash", arg_0_elem_1);
        auto arg_0_elem_2 = Napi::Number::New(env, result[arg_0_id].timeStamp);
        arg_0_elem.Set("timeStamp", arg_0_elem_2);
        auto arg_0_elem_3 = Napi::Number::New(env, result[arg_0_id].amount);
        arg_0_elem.Set("amount", arg_0_elem_3);
        auto arg_0_elem_4 = Napi::Number::New(env, result[arg_0_id].fee);
        arg_0_elem.Set("fee", arg_0_elem_4);
        auto arg_0_elem_5 = Napi::Number::New(env, (int)result[arg_0_id].status);
        arg_0_elem.Set("status", arg_0_elem_5);
        auto arg_0_elem_6 = Napi::Number::New(env, result[arg_0_id].height);
        arg_0_elem.Set("height", arg_0_elem_6);
        auto arg_0_elem_7 = Napi::Number::New(env, result[arg_0_id].blockTime);
        arg_0_elem.Set("blockTime", arg_0_elem_7);
        auto arg_0_elem_8 = Napi::Number::New(env, result[arg_0_id].depth);
        arg_0_elem.Set("depth", arg_0_elem_8);
        auto arg_0_elem_9 = Napi::Array::New(env);
        for(size_t arg_0_elem_9_id = 0; arg_0_elem_9_id < result[arg_0_id].inputs.size(); arg_0_elem_9_id++)
        {
            auto arg_0_elem_9_elem = Napi::Object::New(env);
            auto arg_0_elem_9_elem_1 = Napi::String::New(env, result[arg_0_id].inputs[arg_0_elem_9_id].address);
            arg_0_elem_9_elem.Set("address", arg_0_elem_9_elem_1);
            auto arg_0_elem_9_elem_2 = Napi::String::New(env, result[arg_0_id].inputs[arg_0_elem_9_id].label);
            arg_0_elem_9_elem.Set("label", arg_0_elem_9_elem_2);
            auto arg_0_elem_9_elem_3 = Napi::String::New(env, result[arg_0_id].inputs[arg_0_elem_9_id].desc);
            arg_0_elem_9_elem.Set("desc", arg_0_elem_9_elem_3);
            auto arg_0_elem_9_elem_4 = Napi::Boolean::New(env, result[arg_0_id].inputs[arg_0_elem_9_id].isMine);
            arg_0_elem_9_elem.Set("isMine", arg_0_elem_9_elem_4);

            arg_0_elem_9.Set((int)arg_0_elem_9_id,arg_0_elem_9_elem);
        }

        arg_0_elem.Set("inputs", arg_0_elem_9);
        auto arg_0_elem_10 = Napi::Array::New(env);
        for(size_t arg_0_elem_10_id = 0; arg_0_elem_10_id < result[arg_0_id].outputs.size(); arg_0_elem_10_id++)
        {
            auto arg_0_elem_10_elem = Napi::Object::New(env);
            auto arg_0_elem_10_elem_1 = Napi::Number::New(env, result[arg_0_id].outputs[arg_0_elem_10_id].amount);
            arg_0_elem_10_elem.Set("amount", arg_0_elem_10_elem_1);
            auto arg_0_elem_10_elem_2 = Napi::String::New(env, result[arg_0_id].outputs[arg_0_elem_10_id].address);
            arg_0_elem_10_elem.Set("address", arg_0_elem_10_elem_2);
            auto arg_0_elem_10_elem_3 = Napi::String::New(env, result[arg_0_id].outputs[arg_0_elem_10_id].label);
            arg_0_elem_10_elem.Set("label", arg_0_elem_10_elem_3);
            auto arg_0_elem_10_elem_4 = Napi::String::New(env, result[arg_0_id].outputs[arg_0_elem_10_id].desc);
            arg_0_elem_10_elem.Set("desc", arg_0_elem_10_elem_4);
            auto arg_0_elem_10_elem_5 = Napi::Boolean::New(env, result[arg_0_id].outputs[arg_0_elem_10_id].isMine);
            arg_0_elem_10_elem.Set("isMine", arg_0_elem_10_elem_5);

            arg_0_elem_10.Set((int)arg_0_elem_10_id,arg_0_elem_10_elem);
        }

        arg_0_elem.Set("outputs", arg_0_elem_10);

        arg_0.Set((int)arg_0_id,arg_0_elem);
    }


    return arg_0;
}
Napi::Value NJSUnifiedBackend::getTransaction(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::getTransaction needs 1 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();

    auto result = UnifiedBackend::getTransaction(arg_0);

    //Wrap result in node object
    auto arg_1 = Napi::Object::New(env);
    auto arg_1_1 = Napi::String::New(env, result.txHash);
    arg_1.Set("txHash", arg_1_1);
    auto arg_1_2 = Napi::Number::New(env, result.timeStamp);
    arg_1.Set("timeStamp", arg_1_2);
    auto arg_1_3 = Napi::Number::New(env, result.amount);
    arg_1.Set("amount", arg_1_3);
    auto arg_1_4 = Napi::Number::New(env, result.fee);
    arg_1.Set("fee", arg_1_4);
    auto arg_1_5 = Napi::Number::New(env, (int)result.status);
    arg_1.Set("status", arg_1_5);
    auto arg_1_6 = Napi::Number::New(env, result.height);
    arg_1.Set("height", arg_1_6);
    auto arg_1_7 = Napi::Number::New(env, result.blockTime);
    arg_1.Set("blockTime", arg_1_7);
    auto arg_1_8 = Napi::Number::New(env, result.depth);
    arg_1.Set("depth", arg_1_8);
    auto arg_1_9 = Napi::Array::New(env);
    for(size_t arg_1_9_id = 0; arg_1_9_id < result.inputs.size(); arg_1_9_id++)
    {
        auto arg_1_9_elem = Napi::Object::New(env);
        auto arg_1_9_elem_1 = Napi::String::New(env, result.inputs[arg_1_9_id].address);
        arg_1_9_elem.Set("address", arg_1_9_elem_1);
        auto arg_1_9_elem_2 = Napi::String::New(env, result.inputs[arg_1_9_id].label);
        arg_1_9_elem.Set("label", arg_1_9_elem_2);
        auto arg_1_9_elem_3 = Napi::String::New(env, result.inputs[arg_1_9_id].desc);
        arg_1_9_elem.Set("desc", arg_1_9_elem_3);
        auto arg_1_9_elem_4 = Napi::Boolean::New(env, result.inputs[arg_1_9_id].isMine);
        arg_1_9_elem.Set("isMine", arg_1_9_elem_4);

        arg_1_9.Set((int)arg_1_9_id,arg_1_9_elem);
    }

    arg_1.Set("inputs", arg_1_9);
    auto arg_1_10 = Napi::Array::New(env);
    for(size_t arg_1_10_id = 0; arg_1_10_id < result.outputs.size(); arg_1_10_id++)
    {
        auto arg_1_10_elem = Napi::Object::New(env);
        auto arg_1_10_elem_1 = Napi::Number::New(env, result.outputs[arg_1_10_id].amount);
        arg_1_10_elem.Set("amount", arg_1_10_elem_1);
        auto arg_1_10_elem_2 = Napi::String::New(env, result.outputs[arg_1_10_id].address);
        arg_1_10_elem.Set("address", arg_1_10_elem_2);
        auto arg_1_10_elem_3 = Napi::String::New(env, result.outputs[arg_1_10_id].label);
        arg_1_10_elem.Set("label", arg_1_10_elem_3);
        auto arg_1_10_elem_4 = Napi::String::New(env, result.outputs[arg_1_10_id].desc);
        arg_1_10_elem.Set("desc", arg_1_10_elem_4);
        auto arg_1_10_elem_5 = Napi::Boolean::New(env, result.outputs[arg_1_10_id].isMine);
        arg_1_10_elem.Set("isMine", arg_1_10_elem_5);

        arg_1_10.Set((int)arg_1_10_id,arg_1_10_elem);
    }

    arg_1.Set("outputs", arg_1_10);


    return arg_1;
}
Napi::Value NJSUnifiedBackend::getMutationHistory(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::getMutationHistory needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::getMutationHistory();

    //Wrap result in node object
    auto arg_0 = Napi::Array::New(env);
    for(size_t arg_0_id = 0; arg_0_id < result.size(); arg_0_id++)
    {
        auto arg_0_elem = Napi::Object::New(env);
        auto arg_0_elem_1 = Napi::Number::New(env, result[arg_0_id].change);
        arg_0_elem.Set("change", arg_0_elem_1);
        auto arg_0_elem_2 = Napi::Number::New(env, result[arg_0_id].timestamp);
        arg_0_elem.Set("timestamp", arg_0_elem_2);
        auto arg_0_elem_3 = Napi::String::New(env, result[arg_0_id].txHash);
        arg_0_elem.Set("txHash", arg_0_elem_3);
        auto arg_0_elem_4 = Napi::Number::New(env, (int)result[arg_0_id].status);
        arg_0_elem.Set("status", arg_0_elem_4);
        auto arg_0_elem_5 = Napi::Number::New(env, result[arg_0_id].depth);
        arg_0_elem.Set("depth", arg_0_elem_5);

        arg_0.Set((int)arg_0_id,arg_0_elem);
    }


    return arg_0;
}
Napi::Value NJSUnifiedBackend::getAddressBookRecords(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::getAddressBookRecords needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::getAddressBookRecords();

    //Wrap result in node object
    auto arg_0 = Napi::Array::New(env);
    for(size_t arg_0_id = 0; arg_0_id < result.size(); arg_0_id++)
    {
        auto arg_0_elem = Napi::Object::New(env);
        auto arg_0_elem_1 = Napi::String::New(env, result[arg_0_id].address);
        arg_0_elem.Set("address", arg_0_elem_1);
        auto arg_0_elem_2 = Napi::String::New(env, result[arg_0_id].name);
        arg_0_elem.Set("name", arg_0_elem_2);
        auto arg_0_elem_3 = Napi::String::New(env, result[arg_0_id].desc);
        arg_0_elem.Set("desc", arg_0_elem_3);
        auto arg_0_elem_4 = Napi::String::New(env, result[arg_0_id].purpose);
        arg_0_elem.Set("purpose", arg_0_elem_4);

        arg_0.Set((int)arg_0_id,arg_0_elem);
    }


    return arg_0;
}
void NJSUnifiedBackend::addAddressBookRecord(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::addAddressBookRecord needs 1 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto field_arg_0_1 = info[0].ToObject().Get("address");
    if (field_arg_0_1.IsEmpty() || field_arg_0_1.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'address' field").ThrowAsJavaScriptException();
        return;
    }
    std::string arg_0_1 = field_arg_0_1.As<Napi::String>();

    auto field_arg_0_2 = info[0].ToObject().Get("name");
    if (field_arg_0_2.IsEmpty() || field_arg_0_2.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'name' field").ThrowAsJavaScriptException();
        return;
    }
    std::string arg_0_2 = field_arg_0_2.As<Napi::String>();

    auto field_arg_0_3 = info[0].ToObject().Get("desc");
    if (field_arg_0_3.IsEmpty() || field_arg_0_3.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'desc' field").ThrowAsJavaScriptException();
        return;
    }
    std::string arg_0_3 = field_arg_0_3.As<Napi::String>();

    auto field_arg_0_4 = info[0].ToObject().Get("purpose");
    if (field_arg_0_4.IsEmpty() || field_arg_0_4.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'purpose' field").ThrowAsJavaScriptException();
        return;
    }
    std::string arg_0_4 = field_arg_0_4.As<Napi::String>();
    AddressRecord arg_0(arg_0_1, arg_0_2, arg_0_3, arg_0_4);

    UnifiedBackend::addAddressBookRecord(arg_0);
}
void NJSUnifiedBackend::deleteAddressBookRecord(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::deleteAddressBookRecord needs 1 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto field_arg_0_1 = info[0].ToObject().Get("address");
    if (field_arg_0_1.IsEmpty() || field_arg_0_1.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'address' field").ThrowAsJavaScriptException();
        return;
    }
    std::string arg_0_1 = field_arg_0_1.As<Napi::String>();

    auto field_arg_0_2 = info[0].ToObject().Get("name");
    if (field_arg_0_2.IsEmpty() || field_arg_0_2.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'name' field").ThrowAsJavaScriptException();
        return;
    }
    std::string arg_0_2 = field_arg_0_2.As<Napi::String>();

    auto field_arg_0_3 = info[0].ToObject().Get("desc");
    if (field_arg_0_3.IsEmpty() || field_arg_0_3.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'desc' field").ThrowAsJavaScriptException();
        return;
    }
    std::string arg_0_3 = field_arg_0_3.As<Napi::String>();

    auto field_arg_0_4 = info[0].ToObject().Get("purpose");
    if (field_arg_0_4.IsEmpty() || field_arg_0_4.IsUndefined())
    {
        Napi::Error::New(env, "Object is missing 'purpose' field").ThrowAsJavaScriptException();
        return;
    }
    std::string arg_0_4 = field_arg_0_4.As<Napi::String>();
    AddressRecord arg_0(arg_0_1, arg_0_2, arg_0_3, arg_0_4);

    UnifiedBackend::deleteAddressBookRecord(arg_0);
}
void NJSUnifiedBackend::PersistAndPruneForSPV(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::PersistAndPruneForSPV needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    UnifiedBackend::PersistAndPruneForSPV();
}
void NJSUnifiedBackend::ResetUnifiedProgress(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::ResetUnifiedProgress needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    UnifiedBackend::ResetUnifiedProgress();
}
Napi::Value NJSUnifiedBackend::getPeers(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::getPeers needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::getPeers();

    //Wrap result in node object
    auto arg_0 = Napi::Array::New(env);
    for(size_t arg_0_id = 0; arg_0_id < result.size(); arg_0_id++)
    {
        auto arg_0_elem = Napi::Object::New(env);
        auto arg_0_elem_1 = Napi::Number::New(env, result[arg_0_id].id);
        arg_0_elem.Set("id", arg_0_elem_1);
        auto arg_0_elem_2 = Napi::String::New(env, result[arg_0_id].ip);
        arg_0_elem.Set("ip", arg_0_elem_2);
        auto arg_0_elem_3 = Napi::String::New(env, result[arg_0_id].hostname);
        arg_0_elem.Set("hostname", arg_0_elem_3);
        auto arg_0_elem_4 = Napi::Number::New(env, result[arg_0_id].start_height);
        arg_0_elem.Set("start_height", arg_0_elem_4);
        auto arg_0_elem_5 = Napi::Number::New(env, result[arg_0_id].synced_height);
        arg_0_elem.Set("synced_height", arg_0_elem_5);
        auto arg_0_elem_6 = Napi::Number::New(env, result[arg_0_id].common_height);
        arg_0_elem.Set("common_height", arg_0_elem_6);
        auto arg_0_elem_7 = Napi::Number::New(env, result[arg_0_id].latency);
        arg_0_elem.Set("latency", arg_0_elem_7);
        auto arg_0_elem_8 = Napi::String::New(env, result[arg_0_id].userAgent);
        arg_0_elem.Set("userAgent", arg_0_elem_8);
        auto arg_0_elem_9 = Napi::Number::New(env, result[arg_0_id].protocol);
        arg_0_elem.Set("protocol", arg_0_elem_9);

        arg_0.Set((int)arg_0_id,arg_0_elem);
    }


    return arg_0;
}
Napi::Value NJSUnifiedBackend::getLastSPVBlockInfos(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::getLastSPVBlockInfos needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::getLastSPVBlockInfos();

    //Wrap result in node object
    auto arg_0 = Napi::Array::New(env);
    for(size_t arg_0_id = 0; arg_0_id < result.size(); arg_0_id++)
    {
        auto arg_0_elem = Napi::Object::New(env);
        auto arg_0_elem_1 = Napi::Number::New(env, result[arg_0_id].height);
        arg_0_elem.Set("height", arg_0_elem_1);
        auto arg_0_elem_2 = Napi::Number::New(env, result[arg_0_id].timeStamp);
        arg_0_elem.Set("timeStamp", arg_0_elem_2);
        auto arg_0_elem_3 = Napi::String::New(env, result[arg_0_id].blockHash);
        arg_0_elem.Set("blockHash", arg_0_elem_3);

        arg_0.Set((int)arg_0_id,arg_0_elem);
    }


    return arg_0;
}
Napi::Value NJSUnifiedBackend::getUnifiedProgress(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::getUnifiedProgress needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::getUnifiedProgress();

    //Wrap result in node object
    auto arg_0 = Napi::Number::New(env, result);

    return arg_0;
}
Napi::Value NJSUnifiedBackend::getMonitoringStats(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::getMonitoringStats needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = UnifiedBackend::getMonitoringStats();

    //Wrap result in node object
    auto arg_0 = Napi::Object::New(env);
    auto arg_0_1 = Napi::Number::New(env, result.partialHeight);
    arg_0.Set("partialHeight", arg_0_1);
    auto arg_0_2 = Napi::Number::New(env, result.partialOffset);
    arg_0.Set("partialOffset", arg_0_2);
    auto arg_0_3 = Napi::Number::New(env, result.prunedHeight);
    arg_0.Set("prunedHeight", arg_0_3);
    auto arg_0_4 = Napi::Number::New(env, result.processedSPVHeight);
    arg_0.Set("processedSPVHeight", arg_0_4);
    auto arg_0_5 = Napi::Number::New(env, result.probableHeight);
    arg_0.Set("probableHeight", arg_0_5);


    return arg_0;
}
void NJSUnifiedBackend::RegisterMonitorListener(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::RegisterMonitorListener needs 1 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::shared_ptr<MonitorListener> arg_0(Napi::ObjectWrap<MonitorListener>::Unwrap(info[0].As<Napi::Object>()));

    UnifiedBackend::RegisterMonitorListener(arg_0);
}
void NJSUnifiedBackend::UnregisterMonitorListener(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        Napi::Error::New(env, "NJSUnifiedBackend::UnregisterMonitorListener needs 1 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::shared_ptr<MonitorListener> arg_0(Napi::ObjectWrap<MonitorListener>::Unwrap(info[0].As<Napi::Object>()));

    UnifiedBackend::UnregisterMonitorListener(arg_0);
}

Napi::FunctionReference NJSUnifiedBackend::constructor;

Napi::Object NJSUnifiedBackend::Init(Napi::Env env, Napi::Object exports) {

    // Hook all method callbacks
    Napi::Function func = DefineClass(env, "NJSUnifiedBackend", {
    InstanceMethod("BuildInfo", &NJSUnifiedBackend::BuildInfo),
    InstanceMethod("InitUnityLib", &NJSUnifiedBackend::InitUnityLib),
    InstanceMethod("InitUnityLibThreaded", &NJSUnifiedBackend::InitUnityLibThreaded),
    InstanceMethod("InitWalletFromRecoveryPhrase", &NJSUnifiedBackend::InitWalletFromRecoveryPhrase),
    InstanceMethod("ContinueWalletFromRecoveryPhrase", &NJSUnifiedBackend::ContinueWalletFromRecoveryPhrase),
    InstanceMethod("InitWalletLinkedFromURI", &NJSUnifiedBackend::InitWalletLinkedFromURI),
    InstanceMethod("ContinueWalletLinkedFromURI", &NJSUnifiedBackend::ContinueWalletLinkedFromURI),
    InstanceMethod("InitWalletFromAndroidLegacyProtoWallet", &NJSUnifiedBackend::InitWalletFromAndroidLegacyProtoWallet),
    InstanceMethod("isValidAndroidLegacyProtoWallet", &NJSUnifiedBackend::isValidAndroidLegacyProtoWallet),
    InstanceMethod("IsValidLinkURI", &NJSUnifiedBackend::IsValidLinkURI),
    InstanceMethod("ReplaceWalletLinkedFromURI", &NJSUnifiedBackend::ReplaceWalletLinkedFromURI),
    InstanceMethod("EraseWalletSeedsAndAccounts", &NJSUnifiedBackend::EraseWalletSeedsAndAccounts),
    InstanceMethod("IsValidRecoveryPhrase", &NJSUnifiedBackend::IsValidRecoveryPhrase),
    InstanceMethod("GenerateRecoveryMnemonic", &NJSUnifiedBackend::GenerateRecoveryMnemonic),
    InstanceMethod("GenerateGenesisKeys", &NJSUnifiedBackend::GenerateGenesisKeys),
    InstanceMethod("ComposeRecoveryPhrase", &NJSUnifiedBackend::ComposeRecoveryPhrase),
    InstanceMethod("TerminateUnityLib", &NJSUnifiedBackend::TerminateUnityLib),
    InstanceMethod("QRImageFromString", &NJSUnifiedBackend::QRImageFromString),
    InstanceMethod("GetReceiveAddress", &NJSUnifiedBackend::GetReceiveAddress),
    InstanceMethod("GetRecoveryPhrase", &NJSUnifiedBackend::GetRecoveryPhrase),
    InstanceMethod("IsMnemonicWallet", &NJSUnifiedBackend::IsMnemonicWallet),
    InstanceMethod("IsMnemonicCorrect", &NJSUnifiedBackend::IsMnemonicCorrect),
    InstanceMethod("GetMnemonicDictionary", &NJSUnifiedBackend::GetMnemonicDictionary),
    InstanceMethod("UnlockWallet", &NJSUnifiedBackend::UnlockWallet),
    InstanceMethod("LockWallet", &NJSUnifiedBackend::LockWallet),
    InstanceMethod("ChangePassword", &NJSUnifiedBackend::ChangePassword),
    InstanceMethod("HaveUnconfirmedFunds", &NJSUnifiedBackend::HaveUnconfirmedFunds),
    InstanceMethod("GetBalance", &NJSUnifiedBackend::GetBalance),
    InstanceMethod("DoRescan", &NJSUnifiedBackend::DoRescan),
    InstanceMethod("IsValidRecipient", &NJSUnifiedBackend::IsValidRecipient),
    InstanceMethod("feeForRecipient", &NJSUnifiedBackend::feeForRecipient),
    InstanceMethod("performPaymentToRecipient", &NJSUnifiedBackend::performPaymentToRecipient),
    InstanceMethod("getTransactionHistory", &NJSUnifiedBackend::getTransactionHistory),
    InstanceMethod("getTransaction", &NJSUnifiedBackend::getTransaction),
    InstanceMethod("getMutationHistory", &NJSUnifiedBackend::getMutationHistory),
    InstanceMethod("getAddressBookRecords", &NJSUnifiedBackend::getAddressBookRecords),
    InstanceMethod("addAddressBookRecord", &NJSUnifiedBackend::addAddressBookRecord),
    InstanceMethod("deleteAddressBookRecord", &NJSUnifiedBackend::deleteAddressBookRecord),
    InstanceMethod("PersistAndPruneForSPV", &NJSUnifiedBackend::PersistAndPruneForSPV),
    InstanceMethod("ResetUnifiedProgress", &NJSUnifiedBackend::ResetUnifiedProgress),
    InstanceMethod("getPeers", &NJSUnifiedBackend::getPeers),
    InstanceMethod("getLastSPVBlockInfos", &NJSUnifiedBackend::getLastSPVBlockInfos),
    InstanceMethod("getUnifiedProgress", &NJSUnifiedBackend::getUnifiedProgress),
    InstanceMethod("getMonitoringStats", &NJSUnifiedBackend::getMonitoringStats),
    InstanceMethod("RegisterMonitorListener", &NJSUnifiedBackend::RegisterMonitorListener),
    InstanceMethod("UnregisterMonitorListener", &NJSUnifiedBackend::UnregisterMonitorListener),
    });
    // Create a peristent reference to the class constructor. This will allow a function called on a class prototype and a function called on instance of a class to be distinguished from each other.
    constructor = Napi::Persistent(func);
    // Call the SuppressDestruct() method on the static data prevent the calling to this destructor to reset the reference when the environment is no longer available.
    constructor.SuppressDestruct();
    exports.Set("NJSUnifiedBackend", func);
    return exports;
}
