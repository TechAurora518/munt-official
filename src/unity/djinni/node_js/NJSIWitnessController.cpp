// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from libunity.djinni

#include "NJSIWitnessController.hpp"
using namespace std;

Napi::Value NJSIWitnessController::getNetworkLimits(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        Napi::Error::New(env, "NJSIWitnessController::getNetworkLimits needs 0 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types

    auto result = IWitnessController::getNetworkLimits();

    //Wrap result in node object
    auto arg_0 = Napi::Object::New(env);
    for(auto const& arg_0_elem : result)
    {
        auto arg_0_first = Napi::String::New(env, arg_0_elem.first);
        auto arg_0_second = Napi::String::New(env, arg_0_elem.second);
        arg_0.Set(arg_0_first, arg_0_second);
    }


    return arg_0;
}
Napi::Value NJSIWitnessController::getEstimatedWeight(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        Napi::Error::New(env, "NJSIWitnessController::getEstimatedWeight needs 2 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    auto arg_0 = info[0].ToNumber().Int64Value();
    auto arg_1 = info[1].ToNumber().Int64Value();

    auto result = IWitnessController::getEstimatedWeight(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Napi::Object::New(env);
    auto arg_2_1 = Napi::Value::From(env, result.network_weight);
    arg_2.Set("network_weight", arg_2_1);
    auto arg_2_2 = Napi::Value::From(env, result.weight);
    arg_2.Set("weight", arg_2_2);
    auto arg_2_3 = Napi::Value::From(env, result.parts);
    arg_2.Set("parts", arg_2_3);
    auto arg_2_4 = Napi::Value::From(env, result.estimated_witness_probability);
    arg_2.Set("estimated_witness_probability", arg_2_4);
    auto arg_2_5 = Napi::Value::From(env, result.estimated_blocks_per_day);
    arg_2.Set("estimated_blocks_per_day", arg_2_5);
    auto arg_2_6 = Napi::Value::From(env, result.estimated_daily_earnings);
    arg_2.Set("estimated_daily_earnings", arg_2_6);
    auto arg_2_7 = Napi::Value::From(env, result.estimated_lifetime_earnings);
    arg_2.Set("estimated_lifetime_earnings", arg_2_7);


    return arg_2;
}
Napi::Value NJSIWitnessController::fundWitnessAccount(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();


    //Check if method called with right number of arguments
    if(info.Length() != 4)
    {
        Napi::Error::New(env, "NJSIWitnessController::fundWitnessAccount needs 4 arguments").ThrowAsJavaScriptException();
    }

    //Check if parameters have correct types
    std::string arg_0 = info[0].As<Napi::String>();
    std::string arg_1 = info[1].As<Napi::String>();
    auto arg_2 = info[2].ToNumber().Int64Value();
    auto arg_3 = info[3].ToNumber().Int64Value();

    auto result = IWitnessController::fundWitnessAccount(arg_0,arg_1,arg_2,arg_3);

    //Wrap result in node object
    auto arg_4 = Napi::Object::New(env);
    auto arg_4_1 = Napi::String::New(env, result.status);
    arg_4.Set("status", arg_4_1);
    auto arg_4_2 = Napi::String::New(env, result.txid);
    arg_4.Set("txid", arg_4_2);
    auto arg_4_3 = Napi::Value::From(env, result.fee);
    arg_4.Set("fee", arg_4_3);


    return arg_4;
}

Napi::FunctionReference NJSIWitnessController::constructor;

Napi::Object NJSIWitnessController::Init(Napi::Env env, Napi::Object exports) {

    // Hook all method callbacks
    Napi::Function func = DefineClass(env, "NJSIWitnessController", {
    InstanceMethod("getNetworkLimits", &NJSIWitnessController::getNetworkLimits),
    InstanceMethod("getEstimatedWeight", &NJSIWitnessController::getEstimatedWeight),
    InstanceMethod("fundWitnessAccount", &NJSIWitnessController::fundWitnessAccount),
    });
    // Create a peristent reference to the class constructor. This will allow a function called on a class prototype and a function called on instance of a class to be distinguished from each other.
    constructor = Napi::Persistent(func);
    // Call the SuppressDestruct() method on the static data prevent the calling to this destructor to reset the reference when the environment is no longer available.
    constructor.SuppressDestruct();
    exports.Set("NJSIWitnessController", func);
    return exports;
}
