// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from libunity.djinni

#include "NJSGuldenUnifiedBackendCpp.hpp"
#include "NJSObjectWrapper.hpp"

using namespace v8;
using namespace node;
using namespace std;

NAN_METHOD(NJSGuldenUnifiedBackend::InitUnityLib) {

    //Check if method called with right number of arguments
    if(info.Length() != 7)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::InitUnityLib needs 7 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);
    String::Utf8Value string_arg_1(info[1]->ToString());
    auto arg_1 = std::string(*string_arg_1);
    auto arg_2 = Nan::To<int64_t>(info[2]).FromJust();
    auto arg_3 = Nan::To<int64_t>(info[3]).FromJust();
    auto arg_4 = Nan::To<bool>(info[4]).FromJust();
    Local<Object> njs_arg_5 = info[5]->ToObject(Nan::GetCurrentContext()).ToLocalChecked();
    auto arg_5 = djinni::js::ObjectWrapper<GuldenUnifiedFrontend>::Unwrap(njs_arg_5);

    String::Utf8Value string_arg_6(info[6]->ToString());
    auto arg_6 = std::string(*string_arg_6);

    auto result = GuldenUnifiedBackend::InitUnityLib(arg_0,arg_1,arg_2,arg_3,arg_4,arg_5,arg_6);

    //Wrap result in node object
    auto arg_7 = Nan::New<Int32>(result);

    //Return result
    info.GetReturnValue().Set(arg_7);
}
NAN_METHOD(NJSGuldenUnifiedBackend::InitUnityLibThreaded) {

    //Check if method called with right number of arguments
    if(info.Length() != 7)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::InitUnityLibThreaded needs 7 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);
    String::Utf8Value string_arg_1(info[1]->ToString());
    auto arg_1 = std::string(*string_arg_1);
    auto arg_2 = Nan::To<int64_t>(info[2]).FromJust();
    auto arg_3 = Nan::To<int64_t>(info[3]).FromJust();
    auto arg_4 = Nan::To<bool>(info[4]).FromJust();
    Local<Object> njs_arg_5 = info[5]->ToObject(Nan::GetCurrentContext()).ToLocalChecked();
    auto arg_5 = djinni::js::ObjectWrapper<GuldenUnifiedFrontend>::Unwrap(njs_arg_5);

    String::Utf8Value string_arg_6(info[6]->ToString());
    auto arg_6 = std::string(*string_arg_6);
     GuldenUnifiedBackend::InitUnityLibThreaded(arg_0,arg_1,arg_2,arg_3,arg_4,arg_5,arg_6);
}
NAN_METHOD(NJSGuldenUnifiedBackend::InitWalletFromRecoveryPhrase) {

    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::InitWalletFromRecoveryPhrase needs 2 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);
    String::Utf8Value string_arg_1(info[1]->ToString());
    auto arg_1 = std::string(*string_arg_1);

    auto result = GuldenUnifiedBackend::InitWalletFromRecoveryPhrase(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_2);
}
NAN_METHOD(NJSGuldenUnifiedBackend::ContinueWalletFromRecoveryPhrase) {

    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::ContinueWalletFromRecoveryPhrase needs 2 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);
    String::Utf8Value string_arg_1(info[1]->ToString());
    auto arg_1 = std::string(*string_arg_1);

    auto result = GuldenUnifiedBackend::ContinueWalletFromRecoveryPhrase(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_2);
}
NAN_METHOD(NJSGuldenUnifiedBackend::InitWalletLinkedFromURI) {

    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::InitWalletLinkedFromURI needs 2 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);
    String::Utf8Value string_arg_1(info[1]->ToString());
    auto arg_1 = std::string(*string_arg_1);

    auto result = GuldenUnifiedBackend::InitWalletLinkedFromURI(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_2);
}
NAN_METHOD(NJSGuldenUnifiedBackend::ContinueWalletLinkedFromURI) {

    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::ContinueWalletLinkedFromURI needs 2 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);
    String::Utf8Value string_arg_1(info[1]->ToString());
    auto arg_1 = std::string(*string_arg_1);

    auto result = GuldenUnifiedBackend::ContinueWalletLinkedFromURI(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_2);
}
NAN_METHOD(NJSGuldenUnifiedBackend::InitWalletFromAndroidLegacyProtoWallet) {

    //Check if method called with right number of arguments
    if(info.Length() != 3)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::InitWalletFromAndroidLegacyProtoWallet needs 3 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);
    String::Utf8Value string_arg_1(info[1]->ToString());
    auto arg_1 = std::string(*string_arg_1);
    String::Utf8Value string_arg_2(info[2]->ToString());
    auto arg_2 = std::string(*string_arg_2);

    auto result = GuldenUnifiedBackend::InitWalletFromAndroidLegacyProtoWallet(arg_0,arg_1,arg_2);

    //Wrap result in node object
    auto arg_3 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_3);
}
NAN_METHOD(NJSGuldenUnifiedBackend::isValidAndroidLegacyProtoWallet) {

    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::isValidAndroidLegacyProtoWallet needs 2 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);
    String::Utf8Value string_arg_1(info[1]->ToString());
    auto arg_1 = std::string(*string_arg_1);

    auto result = GuldenUnifiedBackend::isValidAndroidLegacyProtoWallet(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Nan::New<Integer>((int)result);

    //Return result
    info.GetReturnValue().Set(arg_2);
}
NAN_METHOD(NJSGuldenUnifiedBackend::IsValidLinkURI) {

    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::IsValidLinkURI needs 1 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);

    auto result = GuldenUnifiedBackend::IsValidLinkURI(arg_0);

    //Wrap result in node object
    auto arg_1 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_1);
}
NAN_METHOD(NJSGuldenUnifiedBackend::ReplaceWalletLinkedFromURI) {

    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::ReplaceWalletLinkedFromURI needs 2 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);
    String::Utf8Value string_arg_1(info[1]->ToString());
    auto arg_1 = std::string(*string_arg_1);

    auto result = GuldenUnifiedBackend::ReplaceWalletLinkedFromURI(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_2);
}
NAN_METHOD(NJSGuldenUnifiedBackend::EraseWalletSeedsAndAccounts) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::EraseWalletSeedsAndAccounts needs 0 arguments");
    }

    //Check if parameters have correct types

    auto result = GuldenUnifiedBackend::EraseWalletSeedsAndAccounts();

    //Wrap result in node object
    auto arg_0 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::IsValidRecoveryPhrase) {

    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::IsValidRecoveryPhrase needs 1 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);

    auto result = GuldenUnifiedBackend::IsValidRecoveryPhrase(arg_0);

    //Wrap result in node object
    auto arg_1 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_1);
}
NAN_METHOD(NJSGuldenUnifiedBackend::GenerateRecoveryMnemonic) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::GenerateRecoveryMnemonic needs 0 arguments");
    }

    //Check if parameters have correct types

    auto result = GuldenUnifiedBackend::GenerateRecoveryMnemonic();

    //Wrap result in node object
    auto arg_0 = Nan::New<String>(result).ToLocalChecked();

    //Return result
    info.GetReturnValue().Set(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::ComposeRecoveryPhrase) {

    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::ComposeRecoveryPhrase needs 2 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);
    auto arg_1 = Nan::To<int64_t>(info[1]).FromJust();

    auto result = GuldenUnifiedBackend::ComposeRecoveryPhrase(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Nan::New<String>(result).ToLocalChecked();

    //Return result
    info.GetReturnValue().Set(arg_2);
}
NAN_METHOD(NJSGuldenUnifiedBackend::TerminateUnityLib) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::TerminateUnityLib needs 0 arguments");
    }

    //Check if parameters have correct types
     GuldenUnifiedBackend::TerminateUnityLib();
}
NAN_METHOD(NJSGuldenUnifiedBackend::QRImageFromString) {

    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::QRImageFromString needs 2 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);
    auto arg_1 = Nan::To<int32_t>(info[1]).FromJust();

    auto result = GuldenUnifiedBackend::QRImageFromString(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Nan::New<Object>();
    auto arg_2_1 = Nan::New<Int32>(result.width);
    Nan::DefineOwnProperty(arg_2, Nan::New<String>("width").ToLocalChecked(), arg_2_1);
    Local<Array> arg_2_2 = Nan::New<Array>();
    for(size_t arg_2_2_id = 0; arg_2_2_id < result.pixel_data.size(); arg_2_2_id++)
    {
        auto arg_2_2_elem = Nan::New<Uint32>(result.pixel_data[arg_2_2_id]);
        arg_2_2->Set((int)arg_2_2_id,arg_2_2_elem);
    }

    Nan::DefineOwnProperty(arg_2, Nan::New<String>("pixel_data").ToLocalChecked(), arg_2_2);


    //Return result
    info.GetReturnValue().Set(arg_2);
}
NAN_METHOD(NJSGuldenUnifiedBackend::GetReceiveAddress) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::GetReceiveAddress needs 0 arguments");
    }

    //Check if parameters have correct types

    auto result = GuldenUnifiedBackend::GetReceiveAddress();

    //Wrap result in node object
    auto arg_0 = Nan::New<String>(result).ToLocalChecked();

    //Return result
    info.GetReturnValue().Set(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::GetRecoveryPhrase) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::GetRecoveryPhrase needs 0 arguments");
    }

    //Check if parameters have correct types

    auto result = GuldenUnifiedBackend::GetRecoveryPhrase();

    //Wrap result in node object
    auto arg_0 = Nan::New<String>(result).ToLocalChecked();

    //Return result
    info.GetReturnValue().Set(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::IsMnemonicWallet) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::IsMnemonicWallet needs 0 arguments");
    }

    //Check if parameters have correct types

    auto result = GuldenUnifiedBackend::IsMnemonicWallet();

    //Wrap result in node object
    auto arg_0 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::IsMnemonicCorrect) {

    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::IsMnemonicCorrect needs 1 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);

    auto result = GuldenUnifiedBackend::IsMnemonicCorrect(arg_0);

    //Wrap result in node object
    auto arg_1 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_1);
}
NAN_METHOD(NJSGuldenUnifiedBackend::UnlockWallet) {

    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::UnlockWallet needs 1 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);

    auto result = GuldenUnifiedBackend::UnlockWallet(arg_0);

    //Wrap result in node object
    auto arg_1 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_1);
}
NAN_METHOD(NJSGuldenUnifiedBackend::LockWallet) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::LockWallet needs 0 arguments");
    }

    //Check if parameters have correct types

    auto result = GuldenUnifiedBackend::LockWallet();

    //Wrap result in node object
    auto arg_0 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::ChangePassword) {

    //Check if method called with right number of arguments
    if(info.Length() != 2)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::ChangePassword needs 2 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);
    String::Utf8Value string_arg_1(info[1]->ToString());
    auto arg_1 = std::string(*string_arg_1);

    auto result = GuldenUnifiedBackend::ChangePassword(arg_0,arg_1);

    //Wrap result in node object
    auto arg_2 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_2);
}
NAN_METHOD(NJSGuldenUnifiedBackend::HaveUnconfirmedFunds) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::HaveUnconfirmedFunds needs 0 arguments");
    }

    //Check if parameters have correct types

    auto result = GuldenUnifiedBackend::HaveUnconfirmedFunds();

    //Wrap result in node object
    auto arg_0 = Nan::New<Boolean>(result);

    //Return result
    info.GetReturnValue().Set(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::GetBalance) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::GetBalance needs 0 arguments");
    }

    //Check if parameters have correct types

    auto result = GuldenUnifiedBackend::GetBalance();

    //Wrap result in node object
    auto arg_0 = Nan::New<Number>(result);

    //Return result
    info.GetReturnValue().Set(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::DoRescan) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::DoRescan needs 0 arguments");
    }

    //Check if parameters have correct types
     GuldenUnifiedBackend::DoRescan();
}
NAN_METHOD(NJSGuldenUnifiedBackend::IsValidRecipient) {

    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::IsValidRecipient needs 1 arguments");
    }

    //Check if parameters have correct types

    auto field_arg_0_1 = Nan::Get(info[0]->ToObject(), Nan::New<String>("scheme").ToLocalChecked()).ToLocalChecked();
    String::Utf8Value string_arg_0_1(field_arg_0_1->ToString());
    auto arg_0_1 = std::string(*string_arg_0_1);

    auto field_arg_0_2 = Nan::Get(info[0]->ToObject(), Nan::New<String>("path").ToLocalChecked()).ToLocalChecked();
    String::Utf8Value string_arg_0_2(field_arg_0_2->ToString());
    auto arg_0_2 = std::string(*string_arg_0_2);

    auto field_arg_0_3 = Nan::Get(info[0]->ToObject(), Nan::New<String>("items").ToLocalChecked()).ToLocalChecked();
    unordered_map<std::string, std::string> arg_0_3;
    Local<Map> arg_0_3_container = Local<Map>::Cast(field_arg_0_3);
    auto arg_0_3_prop_names = arg_0_3_container->GetPropertyNames();
    for(uint32_t arg_0_3_id = 0; arg_0_3_id < arg_0_3_prop_names->Length(); arg_0_3_id++)
    {
        auto key = arg_0_3_prop_names->Get(arg_0_3_id);
        auto arg_0_3_key_ctx = arg_0_3_container->Get(Nan::GetCurrentContext(), key).ToLocalChecked();
        if(key->IsString() && arg_0_3_key_ctx->IsString())
        {
            String::Utf8Value string_arg_0_3_key(key->ToString());
            auto arg_0_3_key = std::string(*string_arg_0_3_key);
            String::Utf8Value string_arg_0_3_value(arg_0_3_key_ctx->ToString());
            auto arg_0_3_value = std::string(*string_arg_0_3_value);
            arg_0_3.emplace(arg_0_3_key,arg_0_3_value);
        }
    }

    UriRecord arg_0(arg_0_1, arg_0_2, arg_0_3);


    auto result = GuldenUnifiedBackend::IsValidRecipient(arg_0);

    //Wrap result in node object
    auto arg_1 = Nan::New<Object>();
    auto arg_1_1 = Nan::New<Boolean>(result.valid);
    Nan::DefineOwnProperty(arg_1, Nan::New<String>("valid").ToLocalChecked(), arg_1_1);
    auto arg_1_2 = Nan::New<String>(result.address).ToLocalChecked();
    Nan::DefineOwnProperty(arg_1, Nan::New<String>("address").ToLocalChecked(), arg_1_2);
    auto arg_1_3 = Nan::New<String>(result.label).ToLocalChecked();
    Nan::DefineOwnProperty(arg_1, Nan::New<String>("label").ToLocalChecked(), arg_1_3);
    auto arg_1_4 = Nan::New<String>(result.amount).ToLocalChecked();
    Nan::DefineOwnProperty(arg_1, Nan::New<String>("amount").ToLocalChecked(), arg_1_4);


    //Return result
    info.GetReturnValue().Set(arg_1);
}
NAN_METHOD(NJSGuldenUnifiedBackend::performPaymentToRecipient) {

    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::performPaymentToRecipient needs 1 arguments");
    }

    //Check if parameters have correct types

    auto field_arg_0_1 = Nan::Get(info[0]->ToObject(), Nan::New<String>("valid").ToLocalChecked()).ToLocalChecked();
    auto arg_0_1 = Nan::To<bool>(field_arg_0_1).FromJust();

    auto field_arg_0_2 = Nan::Get(info[0]->ToObject(), Nan::New<String>("address").ToLocalChecked()).ToLocalChecked();
    String::Utf8Value string_arg_0_2(field_arg_0_2->ToString());
    auto arg_0_2 = std::string(*string_arg_0_2);

    auto field_arg_0_3 = Nan::Get(info[0]->ToObject(), Nan::New<String>("label").ToLocalChecked()).ToLocalChecked();
    String::Utf8Value string_arg_0_3(field_arg_0_3->ToString());
    auto arg_0_3 = std::string(*string_arg_0_3);

    auto field_arg_0_4 = Nan::Get(info[0]->ToObject(), Nan::New<String>("amount").ToLocalChecked()).ToLocalChecked();
    String::Utf8Value string_arg_0_4(field_arg_0_4->ToString());
    auto arg_0_4 = std::string(*string_arg_0_4);
    UriRecipient arg_0(arg_0_1, arg_0_2, arg_0_3, arg_0_4);

     GuldenUnifiedBackend::performPaymentToRecipient(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::getTransactionHistory) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::getTransactionHistory needs 0 arguments");
    }

    //Check if parameters have correct types

    auto result = GuldenUnifiedBackend::getTransactionHistory();

    //Wrap result in node object
    Local<Array> arg_0 = Nan::New<Array>();
    for(size_t arg_0_id = 0; arg_0_id < result.size(); arg_0_id++)
    {
        auto arg_0_elem = Nan::New<Object>();
        auto arg_0_elem_1 = Nan::New<String>(result[arg_0_id].txHash).ToLocalChecked();
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("txHash").ToLocalChecked(), arg_0_elem_1);
        auto arg_0_elem_2 = Nan::New<Number>(result[arg_0_id].timeStamp);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("timeStamp").ToLocalChecked(), arg_0_elem_2);
        auto arg_0_elem_3 = Nan::New<Number>(result[arg_0_id].amount);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("amount").ToLocalChecked(), arg_0_elem_3);
        auto arg_0_elem_4 = Nan::New<Number>(result[arg_0_id].fee);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("fee").ToLocalChecked(), arg_0_elem_4);
        auto arg_0_elem_5 = Nan::New<Integer>((int)result[arg_0_id].status);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("status").ToLocalChecked(), arg_0_elem_5);
        auto arg_0_elem_6 = Nan::New<Int32>(result[arg_0_id].height);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("height").ToLocalChecked(), arg_0_elem_6);
        auto arg_0_elem_7 = Nan::New<Number>(result[arg_0_id].blockTime);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("blockTime").ToLocalChecked(), arg_0_elem_7);
        auto arg_0_elem_8 = Nan::New<Int32>(result[arg_0_id].depth);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("depth").ToLocalChecked(), arg_0_elem_8);
        Local<Array> arg_0_elem_9 = Nan::New<Array>();
        for(size_t arg_0_elem_9_id = 0; arg_0_elem_9_id < result[arg_0_id].inputs.size(); arg_0_elem_9_id++)
        {
            auto arg_0_elem_9_elem = Nan::New<Object>();
            auto arg_0_elem_9_elem_1 = Nan::New<String>(result[arg_0_id].inputs[arg_0_elem_9_id].address).ToLocalChecked();
            Nan::DefineOwnProperty(arg_0_elem_9_elem, Nan::New<String>("address").ToLocalChecked(), arg_0_elem_9_elem_1);
            auto arg_0_elem_9_elem_2 = Nan::New<String>(result[arg_0_id].inputs[arg_0_elem_9_id].label).ToLocalChecked();
            Nan::DefineOwnProperty(arg_0_elem_9_elem, Nan::New<String>("label").ToLocalChecked(), arg_0_elem_9_elem_2);
            auto arg_0_elem_9_elem_3 = Nan::New<Boolean>(result[arg_0_id].inputs[arg_0_elem_9_id].isMine);
            Nan::DefineOwnProperty(arg_0_elem_9_elem, Nan::New<String>("isMine").ToLocalChecked(), arg_0_elem_9_elem_3);

            arg_0_elem_9->Set((int)arg_0_elem_9_id,arg_0_elem_9_elem);
        }

        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("inputs").ToLocalChecked(), arg_0_elem_9);
        Local<Array> arg_0_elem_10 = Nan::New<Array>();
        for(size_t arg_0_elem_10_id = 0; arg_0_elem_10_id < result[arg_0_id].outputs.size(); arg_0_elem_10_id++)
        {
            auto arg_0_elem_10_elem = Nan::New<Object>();
            auto arg_0_elem_10_elem_1 = Nan::New<Number>(result[arg_0_id].outputs[arg_0_elem_10_id].amount);
            Nan::DefineOwnProperty(arg_0_elem_10_elem, Nan::New<String>("amount").ToLocalChecked(), arg_0_elem_10_elem_1);
            auto arg_0_elem_10_elem_2 = Nan::New<String>(result[arg_0_id].outputs[arg_0_elem_10_id].address).ToLocalChecked();
            Nan::DefineOwnProperty(arg_0_elem_10_elem, Nan::New<String>("address").ToLocalChecked(), arg_0_elem_10_elem_2);
            auto arg_0_elem_10_elem_3 = Nan::New<String>(result[arg_0_id].outputs[arg_0_elem_10_id].label).ToLocalChecked();
            Nan::DefineOwnProperty(arg_0_elem_10_elem, Nan::New<String>("label").ToLocalChecked(), arg_0_elem_10_elem_3);
            auto arg_0_elem_10_elem_4 = Nan::New<Boolean>(result[arg_0_id].outputs[arg_0_elem_10_id].isMine);
            Nan::DefineOwnProperty(arg_0_elem_10_elem, Nan::New<String>("isMine").ToLocalChecked(), arg_0_elem_10_elem_4);

            arg_0_elem_10->Set((int)arg_0_elem_10_id,arg_0_elem_10_elem);
        }

        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("outputs").ToLocalChecked(), arg_0_elem_10);

        arg_0->Set((int)arg_0_id,arg_0_elem);
    }


    //Return result
    info.GetReturnValue().Set(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::getTransaction) {

    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::getTransaction needs 1 arguments");
    }

    //Check if parameters have correct types
    String::Utf8Value string_arg_0(info[0]->ToString());
    auto arg_0 = std::string(*string_arg_0);

    auto result = GuldenUnifiedBackend::getTransaction(arg_0);

    //Wrap result in node object
    auto arg_1 = Nan::New<Object>();
    auto arg_1_1 = Nan::New<String>(result.txHash).ToLocalChecked();
    Nan::DefineOwnProperty(arg_1, Nan::New<String>("txHash").ToLocalChecked(), arg_1_1);
    auto arg_1_2 = Nan::New<Number>(result.timeStamp);
    Nan::DefineOwnProperty(arg_1, Nan::New<String>("timeStamp").ToLocalChecked(), arg_1_2);
    auto arg_1_3 = Nan::New<Number>(result.amount);
    Nan::DefineOwnProperty(arg_1, Nan::New<String>("amount").ToLocalChecked(), arg_1_3);
    auto arg_1_4 = Nan::New<Number>(result.fee);
    Nan::DefineOwnProperty(arg_1, Nan::New<String>("fee").ToLocalChecked(), arg_1_4);
    auto arg_1_5 = Nan::New<Integer>((int)result.status);
    Nan::DefineOwnProperty(arg_1, Nan::New<String>("status").ToLocalChecked(), arg_1_5);
    auto arg_1_6 = Nan::New<Int32>(result.height);
    Nan::DefineOwnProperty(arg_1, Nan::New<String>("height").ToLocalChecked(), arg_1_6);
    auto arg_1_7 = Nan::New<Number>(result.blockTime);
    Nan::DefineOwnProperty(arg_1, Nan::New<String>("blockTime").ToLocalChecked(), arg_1_7);
    auto arg_1_8 = Nan::New<Int32>(result.depth);
    Nan::DefineOwnProperty(arg_1, Nan::New<String>("depth").ToLocalChecked(), arg_1_8);
    Local<Array> arg_1_9 = Nan::New<Array>();
    for(size_t arg_1_9_id = 0; arg_1_9_id < result.inputs.size(); arg_1_9_id++)
    {
        auto arg_1_9_elem = Nan::New<Object>();
        auto arg_1_9_elem_1 = Nan::New<String>(result.inputs[arg_1_9_id].address).ToLocalChecked();
        Nan::DefineOwnProperty(arg_1_9_elem, Nan::New<String>("address").ToLocalChecked(), arg_1_9_elem_1);
        auto arg_1_9_elem_2 = Nan::New<String>(result.inputs[arg_1_9_id].label).ToLocalChecked();
        Nan::DefineOwnProperty(arg_1_9_elem, Nan::New<String>("label").ToLocalChecked(), arg_1_9_elem_2);
        auto arg_1_9_elem_3 = Nan::New<Boolean>(result.inputs[arg_1_9_id].isMine);
        Nan::DefineOwnProperty(arg_1_9_elem, Nan::New<String>("isMine").ToLocalChecked(), arg_1_9_elem_3);

        arg_1_9->Set((int)arg_1_9_id,arg_1_9_elem);
    }

    Nan::DefineOwnProperty(arg_1, Nan::New<String>("inputs").ToLocalChecked(), arg_1_9);
    Local<Array> arg_1_10 = Nan::New<Array>();
    for(size_t arg_1_10_id = 0; arg_1_10_id < result.outputs.size(); arg_1_10_id++)
    {
        auto arg_1_10_elem = Nan::New<Object>();
        auto arg_1_10_elem_1 = Nan::New<Number>(result.outputs[arg_1_10_id].amount);
        Nan::DefineOwnProperty(arg_1_10_elem, Nan::New<String>("amount").ToLocalChecked(), arg_1_10_elem_1);
        auto arg_1_10_elem_2 = Nan::New<String>(result.outputs[arg_1_10_id].address).ToLocalChecked();
        Nan::DefineOwnProperty(arg_1_10_elem, Nan::New<String>("address").ToLocalChecked(), arg_1_10_elem_2);
        auto arg_1_10_elem_3 = Nan::New<String>(result.outputs[arg_1_10_id].label).ToLocalChecked();
        Nan::DefineOwnProperty(arg_1_10_elem, Nan::New<String>("label").ToLocalChecked(), arg_1_10_elem_3);
        auto arg_1_10_elem_4 = Nan::New<Boolean>(result.outputs[arg_1_10_id].isMine);
        Nan::DefineOwnProperty(arg_1_10_elem, Nan::New<String>("isMine").ToLocalChecked(), arg_1_10_elem_4);

        arg_1_10->Set((int)arg_1_10_id,arg_1_10_elem);
    }

    Nan::DefineOwnProperty(arg_1, Nan::New<String>("outputs").ToLocalChecked(), arg_1_10);


    //Return result
    info.GetReturnValue().Set(arg_1);
}
NAN_METHOD(NJSGuldenUnifiedBackend::getMutationHistory) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::getMutationHistory needs 0 arguments");
    }

    //Check if parameters have correct types

    auto result = GuldenUnifiedBackend::getMutationHistory();

    //Wrap result in node object
    Local<Array> arg_0 = Nan::New<Array>();
    for(size_t arg_0_id = 0; arg_0_id < result.size(); arg_0_id++)
    {
        auto arg_0_elem = Nan::New<Object>();
        auto arg_0_elem_1 = Nan::New<Number>(result[arg_0_id].change);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("change").ToLocalChecked(), arg_0_elem_1);
        auto arg_0_elem_2 = Nan::New<Number>(result[arg_0_id].timestamp);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("timestamp").ToLocalChecked(), arg_0_elem_2);
        auto arg_0_elem_3 = Nan::New<String>(result[arg_0_id].txHash).ToLocalChecked();
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("txHash").ToLocalChecked(), arg_0_elem_3);
        auto arg_0_elem_4 = Nan::New<Integer>((int)result[arg_0_id].status);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("status").ToLocalChecked(), arg_0_elem_4);
        auto arg_0_elem_5 = Nan::New<Int32>(result[arg_0_id].depth);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("depth").ToLocalChecked(), arg_0_elem_5);

        arg_0->Set((int)arg_0_id,arg_0_elem);
    }


    //Return result
    info.GetReturnValue().Set(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::getAddressBookRecords) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::getAddressBookRecords needs 0 arguments");
    }

    //Check if parameters have correct types

    auto result = GuldenUnifiedBackend::getAddressBookRecords();

    //Wrap result in node object
    Local<Array> arg_0 = Nan::New<Array>();
    for(size_t arg_0_id = 0; arg_0_id < result.size(); arg_0_id++)
    {
        auto arg_0_elem = Nan::New<Object>();
        auto arg_0_elem_1 = Nan::New<String>(result[arg_0_id].address).ToLocalChecked();
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("address").ToLocalChecked(), arg_0_elem_1);
        auto arg_0_elem_2 = Nan::New<String>(result[arg_0_id].purpose).ToLocalChecked();
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("purpose").ToLocalChecked(), arg_0_elem_2);
        auto arg_0_elem_3 = Nan::New<String>(result[arg_0_id].name).ToLocalChecked();
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("name").ToLocalChecked(), arg_0_elem_3);

        arg_0->Set((int)arg_0_id,arg_0_elem);
    }


    //Return result
    info.GetReturnValue().Set(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::addAddressBookRecord) {

    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::addAddressBookRecord needs 1 arguments");
    }

    //Check if parameters have correct types

    auto field_arg_0_1 = Nan::Get(info[0]->ToObject(), Nan::New<String>("address").ToLocalChecked()).ToLocalChecked();
    String::Utf8Value string_arg_0_1(field_arg_0_1->ToString());
    auto arg_0_1 = std::string(*string_arg_0_1);

    auto field_arg_0_2 = Nan::Get(info[0]->ToObject(), Nan::New<String>("purpose").ToLocalChecked()).ToLocalChecked();
    String::Utf8Value string_arg_0_2(field_arg_0_2->ToString());
    auto arg_0_2 = std::string(*string_arg_0_2);

    auto field_arg_0_3 = Nan::Get(info[0]->ToObject(), Nan::New<String>("name").ToLocalChecked()).ToLocalChecked();
    String::Utf8Value string_arg_0_3(field_arg_0_3->ToString());
    auto arg_0_3 = std::string(*string_arg_0_3);
    AddressRecord arg_0(arg_0_1, arg_0_2, arg_0_3);

     GuldenUnifiedBackend::addAddressBookRecord(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::deleteAddressBookRecord) {

    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::deleteAddressBookRecord needs 1 arguments");
    }

    //Check if parameters have correct types

    auto field_arg_0_1 = Nan::Get(info[0]->ToObject(), Nan::New<String>("address").ToLocalChecked()).ToLocalChecked();
    String::Utf8Value string_arg_0_1(field_arg_0_1->ToString());
    auto arg_0_1 = std::string(*string_arg_0_1);

    auto field_arg_0_2 = Nan::Get(info[0]->ToObject(), Nan::New<String>("purpose").ToLocalChecked()).ToLocalChecked();
    String::Utf8Value string_arg_0_2(field_arg_0_2->ToString());
    auto arg_0_2 = std::string(*string_arg_0_2);

    auto field_arg_0_3 = Nan::Get(info[0]->ToObject(), Nan::New<String>("name").ToLocalChecked()).ToLocalChecked();
    String::Utf8Value string_arg_0_3(field_arg_0_3->ToString());
    auto arg_0_3 = std::string(*string_arg_0_3);
    AddressRecord arg_0(arg_0_1, arg_0_2, arg_0_3);

     GuldenUnifiedBackend::deleteAddressBookRecord(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::PersistAndPruneForSPV) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::PersistAndPruneForSPV needs 0 arguments");
    }

    //Check if parameters have correct types
     GuldenUnifiedBackend::PersistAndPruneForSPV();
}
NAN_METHOD(NJSGuldenUnifiedBackend::ResetUnifiedProgress) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::ResetUnifiedProgress needs 0 arguments");
    }

    //Check if parameters have correct types
     GuldenUnifiedBackend::ResetUnifiedProgress();
}
NAN_METHOD(NJSGuldenUnifiedBackend::getPeers) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::getPeers needs 0 arguments");
    }

    //Check if parameters have correct types

    auto result = GuldenUnifiedBackend::getPeers();

    //Wrap result in node object
    Local<Array> arg_0 = Nan::New<Array>();
    for(size_t arg_0_id = 0; arg_0_id < result.size(); arg_0_id++)
    {
        auto arg_0_elem = Nan::New<Object>();
        auto arg_0_elem_1 = Nan::New<Number>(result[arg_0_id].id);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("id").ToLocalChecked(), arg_0_elem_1);
        auto arg_0_elem_2 = Nan::New<String>(result[arg_0_id].ip).ToLocalChecked();
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("ip").ToLocalChecked(), arg_0_elem_2);
        auto arg_0_elem_3 = Nan::New<String>(result[arg_0_id].hostname).ToLocalChecked();
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("hostname").ToLocalChecked(), arg_0_elem_3);
        auto arg_0_elem_4 = Nan::New<Int32>(result[arg_0_id].start_height);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("start_height").ToLocalChecked(), arg_0_elem_4);
        auto arg_0_elem_5 = Nan::New<Int32>(result[arg_0_id].synced_height);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("synced_height").ToLocalChecked(), arg_0_elem_5);
        auto arg_0_elem_6 = Nan::New<Int32>(result[arg_0_id].common_height);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("common_height").ToLocalChecked(), arg_0_elem_6);
        auto arg_0_elem_7 = Nan::New<Int32>(result[arg_0_id].latency);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("latency").ToLocalChecked(), arg_0_elem_7);
        auto arg_0_elem_8 = Nan::New<String>(result[arg_0_id].userAgent).ToLocalChecked();
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("userAgent").ToLocalChecked(), arg_0_elem_8);
        auto arg_0_elem_9 = Nan::New<Number>(result[arg_0_id].protocol);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("protocol").ToLocalChecked(), arg_0_elem_9);

        arg_0->Set((int)arg_0_id,arg_0_elem);
    }


    //Return result
    info.GetReturnValue().Set(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::getLastSPVBlockInfos) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::getLastSPVBlockInfos needs 0 arguments");
    }

    //Check if parameters have correct types

    auto result = GuldenUnifiedBackend::getLastSPVBlockInfos();

    //Wrap result in node object
    Local<Array> arg_0 = Nan::New<Array>();
    for(size_t arg_0_id = 0; arg_0_id < result.size(); arg_0_id++)
    {
        auto arg_0_elem = Nan::New<Object>();
        auto arg_0_elem_1 = Nan::New<Int32>(result[arg_0_id].height);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("height").ToLocalChecked(), arg_0_elem_1);
        auto arg_0_elem_2 = Nan::New<Number>(result[arg_0_id].timeStamp);
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("timeStamp").ToLocalChecked(), arg_0_elem_2);
        auto arg_0_elem_3 = Nan::New<String>(result[arg_0_id].blockHash).ToLocalChecked();
        Nan::DefineOwnProperty(arg_0_elem, Nan::New<String>("blockHash").ToLocalChecked(), arg_0_elem_3);

        arg_0->Set((int)arg_0_id,arg_0_elem);
    }


    //Return result
    info.GetReturnValue().Set(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::getMonitoringStats) {

    //Check if method called with right number of arguments
    if(info.Length() != 0)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::getMonitoringStats needs 0 arguments");
    }

    //Check if parameters have correct types

    auto result = GuldenUnifiedBackend::getMonitoringStats();

    //Wrap result in node object
    auto arg_0 = Nan::New<Object>();
    auto arg_0_1 = Nan::New<Int32>(result.partialHeight);
    Nan::DefineOwnProperty(arg_0, Nan::New<String>("partialHeight").ToLocalChecked(), arg_0_1);
    auto arg_0_2 = Nan::New<Int32>(result.partialOffset);
    Nan::DefineOwnProperty(arg_0, Nan::New<String>("partialOffset").ToLocalChecked(), arg_0_2);
    auto arg_0_3 = Nan::New<Int32>(result.prunedHeight);
    Nan::DefineOwnProperty(arg_0, Nan::New<String>("prunedHeight").ToLocalChecked(), arg_0_3);
    auto arg_0_4 = Nan::New<Int32>(result.processedSPVHeight);
    Nan::DefineOwnProperty(arg_0, Nan::New<String>("processedSPVHeight").ToLocalChecked(), arg_0_4);
    auto arg_0_5 = Nan::New<Int32>(result.probableHeight);
    Nan::DefineOwnProperty(arg_0, Nan::New<String>("probableHeight").ToLocalChecked(), arg_0_5);


    //Return result
    info.GetReturnValue().Set(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::RegisterMonitorListener) {

    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::RegisterMonitorListener needs 1 arguments");
    }

    //Check if parameters have correct types
    Local<Object> njs_arg_0 = info[0]->ToObject(Nan::GetCurrentContext()).ToLocalChecked();
    auto arg_0 = djinni::js::ObjectWrapper<GuldenMonitorListener>::Unwrap(njs_arg_0);

     GuldenUnifiedBackend::RegisterMonitorListener(arg_0);
}
NAN_METHOD(NJSGuldenUnifiedBackend::UnregisterMonitorListener) {

    //Check if method called with right number of arguments
    if(info.Length() != 1)
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend::UnregisterMonitorListener needs 1 arguments");
    }

    //Check if parameters have correct types
    Local<Object> njs_arg_0 = info[0]->ToObject(Nan::GetCurrentContext()).ToLocalChecked();
    auto arg_0 = djinni::js::ObjectWrapper<GuldenMonitorListener>::Unwrap(njs_arg_0);

     GuldenUnifiedBackend::UnregisterMonitorListener(arg_0);
}

NAN_METHOD(NJSGuldenUnifiedBackend::New) {
    //Only new allowed
    if(!info.IsConstructCall())
    {
        return Nan::ThrowError("NJSGuldenUnifiedBackend function can only be called as constructor (use New)");
    }
    info.GetReturnValue().Set(info.This());
}


Nan::Persistent<ObjectTemplate> NJSGuldenUnifiedBackend::GuldenUnifiedBackend_prototype;

Local<Object> NJSGuldenUnifiedBackend::wrap(const std::shared_ptr<::GuldenUnifiedBackend> &object) {
    Nan::EscapableHandleScope scope;
    Local<ObjectTemplate> local_prototype = Nan::New(GuldenUnifiedBackend_prototype);

    Local<Object> obj;
    if(!local_prototype.IsEmpty())
    {
        obj = local_prototype->NewInstance();
        djinni::js::ObjectWrapper<::GuldenUnifiedBackend>::Wrap(object, obj);
    }
    else
    {
        Nan::ThrowError("NJSGuldenUnifiedBackend::wrap: object template not valid");
    }
    return scope.Escape(obj);
}

NAN_METHOD(NJSGuldenUnifiedBackend::isNull) {
    auto cpp_implementation = djinni::js::ObjectWrapper<GuldenUnifiedBackend>::Unwrap(info.This());
    auto isNull = !cpp_implementation ? true : false;
    return info.GetReturnValue().Set(Nan::New<Boolean>(isNull));
}

void NJSGuldenUnifiedBackend::Initialize(Local<Object> target) {
    Nan::HandleScope scope;

    Local<FunctionTemplate> func_template = Nan::New<FunctionTemplate>(NJSGuldenUnifiedBackend::New);
    Local<ObjectTemplate> objectTemplate = func_template->InstanceTemplate();
    objectTemplate->SetInternalFieldCount(1);

    func_template->SetClassName(Nan::New<String>("NJSGuldenUnifiedBackend").ToLocalChecked());

    //SetPrototypeMethod all methods
    Nan::SetPrototypeMethod(func_template,"InitUnityLib", InitUnityLib);
    Nan::SetPrototypeMethod(func_template,"InitUnityLibThreaded", InitUnityLibThreaded);
    Nan::SetPrototypeMethod(func_template,"InitWalletFromRecoveryPhrase", InitWalletFromRecoveryPhrase);
    Nan::SetPrototypeMethod(func_template,"ContinueWalletFromRecoveryPhrase", ContinueWalletFromRecoveryPhrase);
    Nan::SetPrototypeMethod(func_template,"InitWalletLinkedFromURI", InitWalletLinkedFromURI);
    Nan::SetPrototypeMethod(func_template,"ContinueWalletLinkedFromURI", ContinueWalletLinkedFromURI);
    Nan::SetPrototypeMethod(func_template,"InitWalletFromAndroidLegacyProtoWallet", InitWalletFromAndroidLegacyProtoWallet);
    Nan::SetPrototypeMethod(func_template,"isValidAndroidLegacyProtoWallet", isValidAndroidLegacyProtoWallet);
    Nan::SetPrototypeMethod(func_template,"IsValidLinkURI", IsValidLinkURI);
    Nan::SetPrototypeMethod(func_template,"ReplaceWalletLinkedFromURI", ReplaceWalletLinkedFromURI);
    Nan::SetPrototypeMethod(func_template,"EraseWalletSeedsAndAccounts", EraseWalletSeedsAndAccounts);
    Nan::SetPrototypeMethod(func_template,"IsValidRecoveryPhrase", IsValidRecoveryPhrase);
    Nan::SetPrototypeMethod(func_template,"GenerateRecoveryMnemonic", GenerateRecoveryMnemonic);
    Nan::SetPrototypeMethod(func_template,"ComposeRecoveryPhrase", ComposeRecoveryPhrase);
    Nan::SetPrototypeMethod(func_template,"TerminateUnityLib", TerminateUnityLib);
    Nan::SetPrototypeMethod(func_template,"QRImageFromString", QRImageFromString);
    Nan::SetPrototypeMethod(func_template,"GetReceiveAddress", GetReceiveAddress);
    Nan::SetPrototypeMethod(func_template,"GetRecoveryPhrase", GetRecoveryPhrase);
    Nan::SetPrototypeMethod(func_template,"IsMnemonicWallet", IsMnemonicWallet);
    Nan::SetPrototypeMethod(func_template,"IsMnemonicCorrect", IsMnemonicCorrect);
    Nan::SetPrototypeMethod(func_template,"UnlockWallet", UnlockWallet);
    Nan::SetPrototypeMethod(func_template,"LockWallet", LockWallet);
    Nan::SetPrototypeMethod(func_template,"ChangePassword", ChangePassword);
    Nan::SetPrototypeMethod(func_template,"HaveUnconfirmedFunds", HaveUnconfirmedFunds);
    Nan::SetPrototypeMethod(func_template,"GetBalance", GetBalance);
    Nan::SetPrototypeMethod(func_template,"DoRescan", DoRescan);
    Nan::SetPrototypeMethod(func_template,"IsValidRecipient", IsValidRecipient);
    Nan::SetPrototypeMethod(func_template,"performPaymentToRecipient", performPaymentToRecipient);
    Nan::SetPrototypeMethod(func_template,"getTransactionHistory", getTransactionHistory);
    Nan::SetPrototypeMethod(func_template,"getTransaction", getTransaction);
    Nan::SetPrototypeMethod(func_template,"getMutationHistory", getMutationHistory);
    Nan::SetPrototypeMethod(func_template,"getAddressBookRecords", getAddressBookRecords);
    Nan::SetPrototypeMethod(func_template,"addAddressBookRecord", addAddressBookRecord);
    Nan::SetPrototypeMethod(func_template,"deleteAddressBookRecord", deleteAddressBookRecord);
    Nan::SetPrototypeMethod(func_template,"PersistAndPruneForSPV", PersistAndPruneForSPV);
    Nan::SetPrototypeMethod(func_template,"ResetUnifiedProgress", ResetUnifiedProgress);
    Nan::SetPrototypeMethod(func_template,"getPeers", getPeers);
    Nan::SetPrototypeMethod(func_template,"getLastSPVBlockInfos", getLastSPVBlockInfos);
    Nan::SetPrototypeMethod(func_template,"getMonitoringStats", getMonitoringStats);
    Nan::SetPrototypeMethod(func_template,"RegisterMonitorListener", RegisterMonitorListener);
    Nan::SetPrototypeMethod(func_template,"UnregisterMonitorListener", UnregisterMonitorListener);
    Nan::SetPrototypeMethod(func_template,"isNull", isNull);
    //Set object prototype
    GuldenUnifiedBackend_prototype.Reset(objectTemplate);

    //Add template to target
    target->Set(Nan::New<String>("NJSGuldenUnifiedBackend").ToLocalChecked(), func_template->GetFunction());
}
